os:putenv("EXOMETER_PACKAGES", "(minimal)"),

MaybeReadFromConfig =
fun ({ok, Content}) ->
        Parts = binary:split(Content, <<"\n">>, [global]),
        %% find only this line which starts with "export APPS="
        [Apps] = [Item || <<"export APPS=\"",Item/binary>> <- Parts],
        %% remove trailing " and conver to string
        binary_to_list(binary:part(Apps, 0, size(Apps) - 1));
    (_) ->
        io:format("WARNING! The configure.out file was not created, using minimal configuration~n"),
        ""
end,

ReadFromConfig =
fun(Path) ->
        case filelib:is_file(Path) of
            true ->
                MaybeReadFromConfig(file:read_file(Path));
            _ ->
                Script = filename:join(["tools", "configure"]),
                os:cmd(Script ++ " with-all without-jingle-sip"),
                MaybeReadFromConfig(file:read_file("configure.out"))
        end
end,

GetEnvApps =
fun() ->
        case os:getenv("APPS") of
            false ->
                ConfigurePath = "configure.out",
                ReadFromConfig(ConfigurePath);
            EnvApps ->
                EnvApps
        end
end,

MaybeConfigureCoveralls =
fun(Config) ->
        case os:getenv("TRAVIS") of
            "true" ->
                JobId   = os:getenv("TRAVIS_JOB_ID"),
                lists:keystore(coveralls_service_job_id, 1, Config, {coveralls_service_job_id, JobId});
            _ ->
                Config
        end
end,

DevAppsToInclude =
fun() ->
        case os:getenv("DEVNODE") of
            false -> [];
            _ -> [meck]
        end
end,

RequiredApps = fun() -> [mongooseim, inets, tools] end,
EnvApps = GetEnvApps(),
EnvAppsToInclude = [ list_to_atom(App) || App <- string:tokens(EnvApps, " \n\r") ],

SetupIncludedApps =
fun(Config, EnvApps) ->
        RelxCfg = proplists:get_value(relx, Config),
        {release, Desc, _Apps} = lists:keyfind(release, 1, RelxCfg),
        AppsToIncludeIn = RequiredApps() ++ DevAppsToInclude() ++ EnvAppsToInclude,
        AppsToInclude = ordsets:to_list(ordsets:from_list(AppsToIncludeIn)),
        NewReleaseCfg = {release, Desc, AppsToInclude},
        NewRelxCfg = lists:keyreplace(release, 1, RelxCfg, NewReleaseCfg),
        lists:keyreplace(relx, 1, Config, {relx, NewRelxCfg})
end,

MaybeFIPSSupport = fun(Config) ->
    code:ensure_loaded(crypto),
    case erlang:function_exported(crypto, info_fips, 0) of
        false ->
            Config;
        _ ->
            io:format("compiling with FIPS mode enabled~n"),
            {erl_opts, ErlOpts} = lists:keyfind(erl_opts, 1, Config),
            NewErlOpts = [{d, fips_mode} | ErlOpts],
            lists:keyreplace(erl_opts, 1, Config, {erl_opts, NewErlOpts})
    end
end,

%% Removes hook handler from provider_hooks list
DisableHooksFor = fun(Config, DisabledPluginName) ->
    Hooks = proplists:get_value(provider_hooks, Config),
    Hooks2 = [[Rule || {_Command, {Plugin, _Call}} = Rule <- Rules,
                       Plugin =/= DisabledPluginName]
              || {PreOrPost, Rules} <- Hooks],
    lists:keyreplace(provider_hooks, 1, Config, {provider_hooks, Hooks2})
end,

%% There are several ways to specify plugin
GetPluginName = fun(Plugin) when is_tuple(Plugin) -> element(1, Plugin);
                   (Plugin) -> Plugin end, %% most likely atom

DisablePlugin = fun(Config, DisabledPluginName) ->
    Plugins = proplists:get_value(plugins, Config),
    Plugins2 = [Plugin || Plugin <- Plugins,
                GetPluginName(Plugin) =/= DisabledPluginName],
    lists:keyreplace(plugins, 1, Config, {plugins, Plugins2})
end,

%% If tools/configure has added elixir application, we keep config as-is
%% Otherwise, we can remove rebar3_elixir_compile and its hooks
MaybeDisableElixirSupport = fun(Config) ->
    case lists:member(elixir, EnvAppsToInclude) of
        true ->
            Config;
        false ->
            Config2 = DisableHooksFor(Config, ex),
            DisablePlugin(Config2, rebar3_elixir_compile)
    end
end,

Config0 = MaybeConfigureCoveralls(CONFIG),
Config1 = SetupIncludedApps(Config0, EnvApps),
Config2 = MaybeFIPSSupport(Config1),
MaybeDisableElixirSupport(Config2).
